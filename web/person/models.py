# coding=utf-8
from xact import xact
from random import uniform
import json
import urllib

from django.db import models
from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from django.conf import settings
from django.core.files.base import ContentFile

from ostrovok_common.storages import CDNImageStorage

from django.conf import settings

from exceptions import *
from poi.provider import get_poi_client

import logging
log = logging.getLogger('web.person.models')

# TODO: move registration methods to manager
class Person(models.Model):

    user = models.OneToOneField(User)
    firstname = models.CharField(null=False, blank=False, max_length=255, verbose_name=u"Имя")
    lastname = models.CharField(null=False, blank=False, max_length=255, verbose_name=u"Фамилия")
    email = models.EmailField(verbose_name=u"Email")
    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)

    photo = models.ImageField(
        db_index=True, upload_to=settings.PERSON_IMAGE_PATH, max_length=2048,
        #storage=CDNImageStorage(formats=settings.PERSON_IMAGE_FORMATS, path=settings.PERSON_IMAGE_PATH),
        verbose_name=u"Фото пользователя"
    )

    def __unicode__(self):
        return '%s %s [%s]' % (self.firstname, self.lastname, self.email)

    @property
    def photo_url(self):
        return "%s%s" % (settings.MEDIA_URL, self.photo)

    def reset_password(self, password):
        person.user.set_password(password)
        person.save()

    @staticmethod
    def _try_already_registred(**kwarg):
        user = authenticate(**kwarg)
        if user is not None and user.is_active:
            try:
                # check if user bound to Person
                exists_person = user.person
                # hack for correct auth backend works
                exists_person.user = user
                raise AlreadyRegistered(exists_person)
            except Person.DoesNotExist:
                # user is not bound - try login by "system" user
                log.error('Trying sign in by User[%s, %s] does not has appropriate Person' % (exists_user.id, email))
                raise RegistrationFail()
                # user has bound Person

    @staticmethod
    def _load_friends(person):
        # TODO: remove provider filter after add another social net
        sp_list = SocialPerson.objects.filter(person=person, provider=SocialPerson.PROVIDER_VKONTAKTE)
        if sp_list.count() == 0:
            return
        for sp in sp_list:
            sp.load_friends()

    @staticmethod
    #@xact
    def register_simple(firstname, lastname, email, password=None):
        if password:
            Person._try_already_registred(username=email, password=password)

        try:
            exists_user = User.objects.get(username=email)
            log.error('Trying sign in by User[%s, %s] does not has appropriate Person' % (exists_user.id, email))
            raise RegistrationFail()
        except User.DoesNotExist:
            pass

        user = User()
        user.username = email
        user.first_name = firstname
        user.last_name = lastname

        if not password:
            # TODO: autogenerated password, send email with it
            password = str(int(uniform(1, 1000000)))

        user.set_password(password)
        user.save()

        user = authenticate(username=email, password=password)

        person = Person()
        person.firstname = firstname
        person.lastname = lastname
        person.email = email
        person.user = user
        person.save()

        return person

    @staticmethod
    #@xact
    def register_provider(provider, access_token, user_id, email=None, **kwargs):
        Person._try_already_registred(access_token=access_token, user_id=user_id)
        sp = provider.fetch_user(access_token, user_id)

        if not sp:
            raise RegistrationFail()

        # TODO: remove after make decision
        email = 'test%d@vkontakte.com' % uniform(1, 10000)
        person = Person.register_simple(
            sp.firstname,
            sp.lastname,
            email
        )
        sp.person = person
        sp.save()
        # download photo
        photo_field = ('photo_big', 'photo_medium', 'photo')
        photo_url = None
        for field in photo_field:
            fetched_person = json.loads(sp.data)
            if field in fetched_person:
                photo_url = fetched_person[field]
                break

        if photo_url:
            #try:
            uf = urllib.urlopen(photo_url)
            content = uf.read()
            uf.close()

            ext = photo_url.split('.').pop()
            person.photo.save('%d.%s' % (person.id, ext), ContentFile(content))
            person.save()
            #except E:
        Person._load_friends(person)
        return person

class PersonEdge(models.Model):
    person_1 = models.OneToOneField('Person', related_name='person_1')
    person_2 = models.OneToOneField('Person', related_name='person_2')

    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)

    social_edge = models.OneToOneField('SocialPersonEdge')

class SocialPerson(models.Model):
    PROVIDER_VKONTAKTE = 'vkontakte'
    PROVIDER_CHOICES = (
        (PROVIDER_VKONTAKTE, 'ВКонтакте'),
    )

    person = models.ForeignKey(Person, null=True)
    firstname = models.CharField(null=False, blank=False, max_length=255)
    lastname = models.CharField(null=False, blank=False, max_length=255)
    birthday = models.DateTimeField(null=True, blank=True)

    provider = models.CharField(choices=PROVIDER_CHOICES, max_length=255)
    external_id = models.IntegerField()
    token = models.CharField(choices=PROVIDER_CHOICES, max_length=255)
    data = models.TextField(blank=True)

    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("provider", "external_id")

    def __unicode__(self):
        return '[%s] %s %s %s' % (self.provider, self.external_id, self.firstname, self.lastname)

    def get_client(self):
        return get_poi_client(self.provider)

    def load_friends(self):
        client = self.get_client()
        friends = client.fetch_friends(self)
        for friend in friends:
            # create social edge
            s_edge = SocialPersonEdge()
            s_edge.person_1 = self
            s_edge.person_2 = friend
            s_edge.save()

            # create edge
            #try:
            #    sp.person
            #except :


    def save(self):
        # process update instead of insert if user with save provider and external id is exist
        if not self.id:
            try:
                exist_obj = SocialPerson.objects.get(provider=self.provider, external_id=self.external_id)
                self.id = exist_obj.id
                self.create_date = exist_obj.create_date
            except SocialPerson.DoesNotExist:
                pass
        super(SocialPerson,self).save()

    def fill_from_person(self, person):
        self.person = person
        self.firstname = person.firstname
        self.lastname = person.lastname

class SocialPersonEdge(models.Model):
    person_1 = models.OneToOneField('SocialPerson', related_name='person_1')
    person_2 = models.OneToOneField('SocialPerson', related_name='person_2')

    create_date = models.DateTimeField(auto_now_add=True)
