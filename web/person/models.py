# coding=utf-8
from xact import xact
from random import uniform
import json
import urllib

from django.db import models
from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from django.conf import settings
from django.core.files.base import ContentFile

from ostrovok_common.storages import CDNImageStorage

from django.conf import settings

from exceptions import *
from poi.provider import get_poi_client

import logging
log = logging.getLogger('web.person.models')

class PersonManager(models.Manager):

    def _load_friends(self, person):
        # TODO: remove provider filter after add another social net
        sp_list = SocialPerson.objects.filter(person=person, provider=SocialPerson.PROVIDER_VKONTAKTE)
        if sp_list.count() == 0:
            return
        for sp in sp_list:
            sp.load_friends()


    def _try_already_registred(self, **kwarg):
        user = authenticate(**kwarg)
        if user is not None and user.is_active:
            try:
                # check if user bound to Person
                exists_person = user.person
                # hack for correct auth backend works
                exists_person.user = user
                raise AlreadyRegistered(exists_person)
            except Person.DoesNotExist:
                # user is not bound - try login by "system" user
                log.error('Trying sign in by User[%s, %s] does not has appropriate Person' % (exists_user.id, email))
                raise RegistrationFail()
                # user has bound Person

    @xact
    def register_simple(self, firstname, lastname, email, password=None, **kwargs):
        if password:
            self._try_already_registred(username=email, password=password)

        try:
            exists_user = User.objects.get(username=email)
            log.error('Trying sign in by User[%s, %s] does not has appropriate Person' % (exists_user.id, email))
            raise RegistrationFail()
        except User.DoesNotExist:
            pass

        user = User()
        user.username = email
        user.first_name = firstname
        user.last_name = lastname

        if not password:
            # TODO: autogenerated password, send email with it
            password = str(int(uniform(1, 1000000)))

        user.set_password(password)
        user.save()

        user = authenticate(username=email, password=password)

        person = Person()
        person.firstname = firstname
        person.lastname = lastname
        person.email = email
        person.user = user
        person.save()

        return person

    @xact
    def register_provider(self, provider, access_token, user_id, email=None, **kwargs):
        self._try_already_registred(access_token=access_token, user_id=user_id)
        sp = provider.fetch_user(access_token, user_id)

        if not sp:
            raise RegistrationFail()

        # TODO: remove after make decision
        email = 'test%d@vkontakte.com' % uniform(1, 10000)
        person = self.register_simple(
            sp.firstname,
            sp.lastname,
            email
        )
        sp.person = person
        sp.save()
        # download photo
        photo_field = ('photo_big', 'photo_medium', 'photo')
        photo_url = None
        for field in photo_field:
            fetched_person = json.loads(sp.data)
            if field in fetched_person:
                photo_url = fetched_person[field]
                break

        if photo_url:
            #try:
            uf = urllib.urlopen(photo_url)
            content = uf.read()
            uf.close()

            ext = photo_url.split('.').pop()
            person.photo.save('%d.%s' % (person.id, ext), ContentFile(content))
            person.save()
            #except E:
        self._load_friends(person)
        return person


# TODO: move registration methods to manager
class Person(models.Model):

    user = models.OneToOneField(User)
    firstname = models.CharField(null=False, blank=False, max_length=255, verbose_name=u"Имя")
    lastname = models.CharField(null=False, blank=False, max_length=255, verbose_name=u"Фамилия")
    email = models.EmailField(verbose_name=u"Email")
    is_email_verified = models.BooleanField(default=False)
    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)

    photo = models.ImageField(
        db_index=True, upload_to=settings.PERSON_IMAGE_PATH, max_length=2048,
        #storage=CDNImageStorage(formats=settings.PERSON_IMAGE_FORMATS, path=settings.PERSON_IMAGE_PATH),
        verbose_name=u"Фото пользователя"
    )

    persons = PersonManager()
    objects = models.Manager()

    def __unicode__(self):
        return '%s %s [%s]' % (self.firstname, self.lastname, self.email)

    @property
    def photo_url(self):
        return "%s%s" % (settings.MEDIA_URL, self.photo)

    def reset_password(self, password):
        person.user.set_password(password)
        person.save()

    @property
    def friends(self):
        #return self.persons.fi
        pass


class PersonEdge(models.Model):
    person_1 = models.ForeignKey('Person', related_name='person_1')
    person_2 = models.ForeignKey('Person', related_name='person_2')

    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)

    social_edge = models.OneToOneField('SocialPersonEdge')

class SocialPerson(models.Model):
    PROVIDER_VKONTAKTE = 'vkontakte'
    PROVIDER_CHOICES = (
        (PROVIDER_VKONTAKTE, 'ВКонтакте'),
    )

    person = models.ForeignKey(Person, null=True)
    firstname = models.CharField(null=False, blank=False, max_length=255)
    lastname = models.CharField(null=False, blank=False, max_length=255)
    birthday = models.DateTimeField(null=True, blank=True)

    provider = models.CharField(choices=PROVIDER_CHOICES, max_length=255)
    external_id = models.IntegerField()
    token = models.CharField(choices=PROVIDER_CHOICES, max_length=255)
    # TODO: change it to JSONField from ostrovok-common and remove loads/dumps from code
    data = models.TextField(blank=True)

    create_date = models.DateTimeField(auto_now_add=True)
    modified_date = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("provider", "external_id")

    def __unicode__(self):
        return '[%s] %s %s %s' % (self.provider, self.external_id, self.firstname, self.lastname)

    def get_client(self):
        return get_poi_client(self.provider)

    def load_friends(self):
        client = self.get_client()
        friends = client.fetch_friends(social_person=self)
        for friend in friends:
            friend.save()

            # create social edge
            s_edge = SocialPersonEdge()
            s_edge.person_1 = self
            s_edge.person_2 = friend
            s_edge.save()

            # create edge
            if friend.person:
                edge = PersonEdge()
                edge.social_edge = s_edge
                edge.person_1 = self.person
                edge.person_2 = friend.person
                edge.save()


class SocialPersonEdge(models.Model):
    person_1 = models.ForeignKey('SocialPerson', related_name='person_1')
    person_2 = models.ForeignKey('SocialPerson', related_name='person_2')

    create_date = models.DateTimeField(auto_now_add=True)
